<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Gated Player - v7 Complete</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --panel-color: #161616;
            --accent-color: #00e5ff;
            --active-color: #00ff88;
            --stop-color: #ff0055;
            --warn-color: #ff9800;
            --text-color: #e0e0e0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            width: 100%;
            padding: 15px 0;
            background: linear-gradient(to bottom, #000, transparent);
            text-align: center;
            margin-bottom: 10px;
        }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 2px; text-transform: uppercase; color: var(--accent-color); text-shadow: 0 0 10px rgba(0,229,255,0.3); }

        .main-container {
            width: 95%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-bottom: 50px;
        }

        /* ステータスバー */
        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--panel-color);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .status-text {
            font-size: 1.2rem;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 130px;
        }
        .status-active { color: var(--active-color); text-shadow: 0 0 8px var(--active-color); }
        .status-inactive { color: var(--stop-color); text-shadow: 0 0 8px var(--stop-color); }
        .status-manual { color: var(--warn-color); }

        /* メーター */
        .meter-wrapper {
            flex-grow: 1;
            margin-left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            transition: opacity 0.3s;
        }
        .meter-label { font-size: 0.7rem; color: #888; display: flex; justify-content: space-between; }
        
        .meter-track {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-color), #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px var(--accent-color);
            transition: width 0.1s linear;
        }
        .meter-hidden { opacity: 0; pointer-events: none; }

        /* プレイヤー */
        .player-frame {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .player-frame iframe {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
        }

        /* コントロールパネル */
        .control-panel {
            background: var(--panel-color);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid #333;
        }

        .panel-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        /* スイッチ群 */
        .toggles-area {
            display: flex;
            gap: 15px;
            justify-content: center;
            width: 100%;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
            margin-bottom: 15px;
        }

        /* Toggle UI */
        .toggle-container {
            display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;
            background: #222; padding: 8px 12px; border-radius: 20px; border: 1px solid #444;
        }
        .toggle-checkbox { display: none; }
        .toggle-switch {
            width: 36px; height: 18px; background: #555; border-radius: 20px; position: relative; transition: 0.3s;
        }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: 0.3s;
        }
        .toggle-checkbox:checked + .toggle-switch { background: var(--accent-color); }
        .toggle-checkbox:checked + .toggle-switch::after { transform: translateX(18px); }
        .toggle-label { font-size: 0.85rem; color: #ccc; }

        /* Input & Buttons */
        .input-group { flex: 1; display: flex; gap: 10px; }
        input[type="text"] {
            flex: 1; background: #222; border: 1px solid #444; color: #fff; padding: 10px; border-radius: 8px; outline: none;
        }
        input[type="text"]:focus { border-color: var(--accent-color); }

        button {
            background: #333; color: #fff; border: 1px solid #444; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.2s;
        }
        button:hover { background: #444; }
        button.primary { background: var(--accent-color); color: #000; border: none; }
        button.primary:hover { background: #33eaff; box-shadow: 0 0 15px rgba(0,229,255,0.4); }

        button.start-btn {
            width: 100%; padding: 20px; font-size: 1.2rem;
            background: linear-gradient(45deg, var(--accent-color), #0091ea);
            color: #000; border: none;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        .slider-group { flex: 1; min-width: 200px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--accent-color); }

        .preset-tags { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px; }
        .tag {
            font-size: 0.8rem; padding: 5px 12px; background: #333; border-radius: 20px; cursor: pointer; white-space: nowrap; border: 1px solid transparent;
        }
        .tag:hover { border-color: var(--accent-color); color: var(--accent-color); }

        #hidden-process { position: absolute; visibility: hidden; }
    </style>
</head>
<body>

    <header>
        <h1><i class="fas fa-network-wired"></i> Kinetic Stream v7</h1>
    </header>

    <div class="main-container">
        
        <button id="startBtn" class="start-btn"><i class="fas fa-power-off"></i> システム起動</button>

        <div class="status-bar">
            <div id="statusIndicator" class="status-text status-inactive">
                <i class="fas fa-pause"></i> <span>STOP</span>
            </div>
            
            <div class="meter-wrapper" id="meterWrapper">
                <div class="meter-label">
                    <span>ACTIVITY LEVEL</span>
                    <span id="meterValue">0%</span>
                </div>
                <div class="meter-track">
                    <div id="motionBar" class="meter-fill"></div>
                </div>
            </div>

            <div style="margin-left: 10px;">
                <button onclick="toggleMeter()" style="padding: 8px 12px;" title="メーター表示切替">
                    <i id="meterIcon" class="fas fa-eye"></i>
                </button>
            </div>
        </div>

        <div class="player-frame">
            <div id="player"></div>
        </div>

        <div class="control-panel">
            
            <div class="toggles-area">
                <label class="toggle-container" title="OFFにすると動き検知を無視します（普通のプレイヤーになります）">
                    <input type="checkbox" id="detectionToggle" class="toggle-checkbox" checked>
                    <div class="toggle-switch"></div>
                    <span class="toggle-label">動き検知 ON</span>
                </label>

                <label class="toggle-container" title="マウスやキーボード操作も動きとしてカウントします">
                    <input type="checkbox" id="pcInputToggle" class="toggle-checkbox" checked>
                    <div class="toggle-switch"></div>
                    <span class="toggle-label">PC操作検知</span>
                </label>
            </div>

            <div class="panel-row">
                <div class="input-group">
                    <input type="text" id="videoUrl" placeholder="YouTube URL貼り付け">
                    <button class="primary" onclick="loadFromUrl()">再生</button>
                </div>
                <button onclick="openYouTubeSearch()"><i class="fab fa-youtube"></i> 検索</button>
            </div>

            <div class="panel-row" style="display: block;">
                <div style="font-size: 0.8rem; color: #888; margin-bottom: 8px;">プリセット:</div>
                <div class="preset-tags">
                    <div class="tag" onclick="setVideo('jfKfPfyJRdk')">Lo-Fi HipHop</div>
                    <div class="tag" onclick="setVideo('5qap5aO4i9A')">Synthwave</div>
                    <div class="tag" onclick="setVideo('lTRiuFIWV54')">Metal</div>
                    <div class="tag" onclick="setVideo('teIjhVd9jFk')">Workout</div>
                    <div class="tag" onclick="setVideo('gDnE-5lD7w8')">Nature</div>
                </div>
            </div>

            <div class="panel-row">
                <div class="slider-group">
                    <div class="slider-label"><span>カメラ感度</span> <span id="sensVal">50</span></div>
                    <input type="range" id="sensitivity" min="10" max="150" value="50">
                </div>
                <div class="slider-group">
                    <div class="slider-label"><span>停止までの余韻 (秒)</span> <span id="decayVal">2.0s</span></div>
                    <input type="range" id="decay" min="0.5" max="10.0" value="2.0" step="0.5">
                </div>
            </div>
        </div>
    </div>

    <div id="hidden-process">
        <video id="webcam" playsinline muted width="320" height="240"></video>
        <canvas id="diff-canvas" width="320" height="240"></canvas>
    </div>

    <script>
        // --- YouTube API Setup ---
        let player;
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                videoId: 'jfKfPfyJRdk',
                playerVars: { 'playsinline': 1, 'rel': 0 },
                events: {
                    'onStateChange': onPlayerStateChange // 状態変化を監視
                }
            });
        }

        // --- 手動停止管理ロジック ---
        let isManuallyPaused = false; // ユーザーが手動で止めたか
        let isSystemAction = false;   // システムが止めたか

        function onPlayerStateChange(event) {
            // 一時停止された時
            if (event.data === YT.PlayerState.PAUSED) {
                if (!isSystemAction) {
                    // システムがやったのでなければ、ユーザーの手動停止とみなす
                    isManuallyPaused = true;
                    updateStatusDisplay("MANUAL PAUSE");
                }
                isSystemAction = false; // フラグリセット
            }
            // 再生された時
            if (event.data === YT.PlayerState.PLAYING) {
                // ユーザーが再生ボタンを押した、またはシステムが再生した
                // いずれにせよ手動停止フラグは解除する
                isManuallyPaused = false;
                isSystemAction = false;
            }
        }

        // --- 動画操作系 ---
        function loadFromUrl() {
            const url = document.getElementById('videoUrl').value;
            let vid = extractVideoID(url);
            if(vid && player && player.loadVideoById) {
                player.loadVideoById(vid);
                isManuallyPaused = false; // 動画変更時はリセット
            }
        }
        function setVideo(id) {
            if(player && player.loadVideoById) {
                player.loadVideoById(id);
                isManuallyPaused = false;
            }
            document.getElementById('videoUrl').value = "https://youtu.be/" + id;
        }
        function openYouTubeSearch() { window.open("https://www.youtube.com", "_blank"); }
        function extractVideoID(url) {
            if (url.includes('v=')) return url.split('v=')[1].split('&')[0];
            if (url.includes('youtu.be/')) return url.split('youtu.be/')[1].split('?')[0];
            return url.length === 11 ? url : null;
        }

        // --- メイン処理 ---
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('diff-canvas');
        const ctx = canvas.getContext('2d');
        
        // UI
        const startBtn = document.getElementById('startBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const motionBar = document.getElementById('motionBar');
        const meterValue = document.getElementById('meterValue');
        const meterWrapper = document.getElementById('meterWrapper');
        const meterIcon = document.getElementById('meterIcon');
        
        // Settings
        const sensInput = document.getElementById('sensitivity');
        const decayInput = document.getElementById('decay');
        const sensValDisp = document.getElementById('sensVal');
        const decayValDisp = document.getElementById('decayVal');
        const pcInputToggle = document.getElementById('pcInputToggle');
        const detectionToggle = document.getElementById('detectionToggle');

        sensInput.addEventListener('input', (e) => sensValDisp.innerText = e.target.value);
        decayInput.addEventListener('input', (e) => decayValDisp.innerText = e.target.value + "s");

        let lastImageData = null;
        let lastActiveTime = 0; 
        let isRunning = false;
        let currentState = "STOPPED"; 
        let isMeterVisible = true;
        let pcInputDetectedFrame = false;

        // PC操作監視
        function onPcInput() {
            if (!isRunning || !pcInputToggle.checked || !detectionToggle.checked) return;
            lastActiveTime = Date.now();
            pcInputDetectedFrame = true;
        }
        ['mousemove', 'keydown', 'click', 'scroll'].forEach(ev => document.addEventListener(ev, onPcInput));

        // メーター表示切替（アイコン変化）
        function toggleMeter() {
            isMeterVisible = !isMeterVisible;
            if(isMeterVisible) {
                meterWrapper.classList.remove('meter-hidden');
                meterIcon.className = "fas fa-eye"; // 開いた目
            } else {
                meterWrapper.classList.add('meter-hidden');
                meterIcon.className = "fas fa-eye-slash"; // 斜線の目
            }
        }

        function updateStatusDisplay(state) {
            if (state === "PLAYING") {
                statusIndicator.innerHTML = '<i class="fas fa-play"></i> <span>ACTIVE</span>';
                statusIndicator.className = "status-text status-active";
            } else if (state === "STOPPED") {
                statusIndicator.innerHTML = '<i class="fas fa-pause"></i> <span>STOP</span>';
                statusIndicator.className = "status-text status-inactive";
            } else if (state === "MANUAL PAUSE") {
                statusIndicator.innerHTML = '<i class="fas fa-hand-paper"></i> <span>MANUAL</span>';
                statusIndicator.className = "status-text status-manual";
            }
        }

        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                video.onloadedmetadata = () => { video.play(); };

                if(player && player.playVideo) {
                    player.mute(); player.playVideo();
                    setTimeout(() => { player.pauseVideo(); player.unMute(); }, 500);
                }

                startBtn.style.display = 'none';
                isRunning = true;
                loop();
            } catch(e) {
                alert("カメラ起動エラー");
            }
        });

        function loop() {
            if(!isRunning) return;

            // 1. 動き検知（カメラ）
            let score = 0;
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = frame.data;
                
                if (lastImageData) {
                    const lastData = lastImageData.data;
                    for (let i = 0; i < data.length; i += 4 * 20) {
                        const diff = Math.abs(data[i] - lastData[i]) + Math.abs(data[i+1] - lastData[i+1]) + Math.abs(data[i+2] - lastData[i+2]);
                        if (diff > 40) score++;
                    }
                }
                lastImageData = frame;
            }

            // 2. 検知がONの場合のみ時間を更新
            if (detectionToggle.checked) {
                const threshold = parseInt(sensInput.value);
                if (score > (threshold / 2)) {
                    lastActiveTime = Date.now();
                }
            }

            // 3. メーター更新
            let displayScore = Math.min(100, score / 3);
            if (pcInputDetectedFrame) {
                displayScore = 100;
                pcInputDetectedFrame = false;
            }
            if (isMeterVisible) {
                motionBar.style.width = displayScore + "%";
                meterValue.innerText = Math.floor(displayScore) + "%";
                if(displayScore > 80) motionBar.style.background = "var(--active-color)";
                else motionBar.style.background = "linear-gradient(90deg, var(--accent-color), #fff)";
            }

            // 4. 再生制御ロジック
            const now = Date.now();
            const decayMs = parseFloat(decayInput.value) * 1000;

            // 手動停止中は、何があっても再生しない
            if (isManuallyPaused) {
                if (currentState !== "MANUAL PAUSE") {
                    currentState = "MANUAL PAUSE";
                    updateStatusDisplay("MANUAL PAUSE");
                }
                requestAnimationFrame(loop);
                return;
            }

            // 検知OFFなら何もしない（ユーザーが自由に再生/停止できる状態を維持）
            if (!detectionToggle.checked) {
                 // UIだけリセットしておく
                 if (currentState !== "STOPPED" && currentState !== "PLAYING") {
                     updateStatusDisplay("STOPPED"); 
                 }
                 requestAnimationFrame(loop);
                 return;
            }

            // 自動制御
            if (now < lastActiveTime + decayMs) {
                // --- PLAY ---
                if (currentState !== "PLAYING") {
                    currentState = "PLAYING";
                    updateStatusDisplay("PLAYING");
                    if(player && player.playVideo) {
                        isSystemAction = true; // システムによる操作フラグ
                        player.playVideo();
                    }
                }
            } else {
                // --- STOP ---
                if (currentState !== "STOPPED") {
                    currentState = "STOPPED";
                    updateStatusDisplay("STOPPED");
                    if(player && player.pauseVideo) {
                        isSystemAction = true; // システムによる操作フラグ
                        player.pauseVideo();
                    }
                }
            }

            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
